function isNodeInRange(range: Range, node: Node): boolean {
	try {
		const length = node.nodeValue?.length ?? node.childNodes.length
		return (
			// Check start of node is before end of range.
			range.comparePoint(node, 0) <= 0 &&
			// Check end of node is after start of range.
			range.comparePoint(node, length) >= 0
		)
	} catch (e) {
		// `comparePoint` may fail if the `range` and `node` do not share a common
		// ancestor or `node` is a doctype.
		return false
	}
}

export function wholeTextNodesInRange(range: Range): Text[] {
	if (range.collapsed) {
		// Exit early for an empty range to avoid an edge case that breaks the algorithm
		// below. Splitting a text node at the start of an empty range can leave the
		// range ending in the left part rather than the right part.
		return []
	}

	/** @type {Node|null} */
	let root = range.commonAncestorContainer
	if (root.nodeType !== Node.ELEMENT_NODE) {
		// If the common ancestor is not an element, set it to the parent element to
		// ensure that the loop below visits any text nodes generated by splitting
		// the common ancestor.
		//
		// Note that `parentElement` may be `null`.
		root = root.parentElement
	}
	if (!root) {
		// If there is no root element then we won't be able to insert highlights,
		// so exit here.
		return []
	}

	const textNodes = []
	const nodeIter = /** @type {Document} */ root.ownerDocument.createNodeIterator(
		root,
		NodeFilter.SHOW_TEXT // Only return `Text` nodes.
	)
	let node
	while ((node = nodeIter.nextNode())) {
		if (!isNodeInRange(range, node)) {
			continue
		}
		let text = /** @type {Text} */ node

		if (text === range.startContainer && range.startOffset > 0) {
			// Split `text` where the range starts. The split will create a new `Text`
			// node which will be in the range and will be visited in the next loop iteration.
			text.splitText(range.startOffset)
			continue
		}

		if (text === range.endContainer && range.endOffset < text.data.length) {
			// Split `text` where the range ends, leaving it as the part in the range.
			text.splitText(range.endOffset)
		}

		textNodes.push(text)
	}

	return textNodes
}

function replaceWith(node, replacements) {
	const parent = /** @type {Node} */ node.parentNode
	replacements.forEach(r => parent.insertBefore(r, node))
	node.remove()
}

export function removeHighlights(highlights) {
	for (let h of highlights) {
		if (h.parentNode) {
			const parent = h.parentNode
			const children = Array.from(h.childNodes)
			replaceWith(h, children)
			parent.normalize()
		}
	}
}
